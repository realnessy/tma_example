{"version":3,"file":"index.js","sources":["../../sdk/dist/index.js","../src/useIntegration.ts"],"sourcesContent":["var We = Object.defineProperty;\nvar Ue = (t, e, s) => e in t ? We(t, e, { enumerable: !0, configurable: !0, writable: !0, value: s }) : t[e] = s;\nvar c = (t, e, s) => Ue(t, typeof e != \"symbol\" ? e + \"\" : e, s);\nfunction oe(t, e) {\n  let s;\n  const n = () => {\n    s !== void 0 && e && e(s), s = void 0;\n  };\n  return [() => s === void 0 ? s = t(n) : s, n];\n}\nfunction ae(t) {\n  const e = M(), { count: s } = e;\n  e.unsubscribe(t), s && !e.count && it();\n}\nfunction He(t) {\n  return M().subscribe(t), () => ae(t);\n}\nclass Oe {\n  constructor(e, s = {}) {\n    this.scope = e, this.options = s;\n  }\n  /**\n   * Prints message into a console in case, logger is currently enabled.\n   * @param level - log level.\n   * @param args - arguments.\n   */\n  print(e, ...s) {\n    const n = /* @__PURE__ */ new Date(), r = Intl.DateTimeFormat(\"en-GB\", {\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      fractionalSecondDigits: 3,\n      timeZone: \"UTC\"\n    }).format(n), { textColor: i, bgColor: o } = this.options, a = \"font-weight: bold;padding: 0 5px;border-radius:5px\";\n    console[e](\n      `%c${r}%c / %c${this.scope}`,\n      `${a};background-color: lightblue;color:black`,\n      \"\",\n      `${a};${i ? `color:${i};` : \"\"}${o ? `background-color:${o}` : \"\"}`,\n      ...s\n    );\n  }\n  /**\n   * Prints error message into a console.\n   * @param args\n   */\n  error(...e) {\n    this.print(\"error\", ...e);\n  }\n  /**\n   * Prints log message into a console.\n   * @param args\n   */\n  log(...e) {\n    this.print(\"log\", ...e);\n  }\n}\nconst F = new Oe(\"SDK\", {\n  bgColor: \"forestgreen\",\n  textColor: \"white\"\n});\nlet O = !1;\nconst se = ({ name: t, payload: e }) => {\n  F.log(\"Event received:\", e ? { name: t, payload: e } : { name: t });\n};\nfunction Kt(t) {\n  O !== t && (O = t, t ? He(se) : ae(se));\n}\nfunction Ge(...t) {\n  O && F.log(...t);\n}\nclass R {\n  constructor() {\n    c(this, \"listeners\", /* @__PURE__ */ new Map());\n    c(this, \"listenersCount\", 0);\n    c(this, \"subscribeListeners\", []);\n  }\n  /**\n   * Removes all event listeners.\n   */\n  clear() {\n    this.listeners.clear(), this.subscribeListeners = [];\n  }\n  /**\n   * Returns count of bound listeners.\n   */\n  get count() {\n    return this.listenersCount + this.subscribeListeners.length;\n  }\n  emit(e, ...s) {\n    this.subscribeListeners.forEach((r) => r({\n      event: e,\n      args: s\n    })), (this.listeners.get(e) || []).forEach(([r, i]) => {\n      r(...s), i && this.off(e, r);\n    });\n  }\n  /**\n   * Adds new event listener.\n   * @param event - event name.\n   * @param listener - event listener.\n   * @param once - should listener be called only once.\n   * @returns Function to remove bound event listener.\n   */\n  on(e, s, n) {\n    let r = this.listeners.get(e);\n    return r || this.listeners.set(e, r = []), r.push([s, n]), this.listenersCount += 1, () => this.off(e, s);\n  }\n  /**\n   * Removes event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param event - event name.\n   * @param listener - event listener.\n   */\n  off(e, s) {\n    const n = this.listeners.get(e) || [];\n    for (let r = 0; r < n.length; r += 1)\n      if (s === n[r][0]) {\n        n.splice(r, 1), this.listenersCount -= 1;\n        return;\n      }\n  }\n  /**\n   * Adds a new event listener for all events.\n   * @param listener - event listener.\n   * @returns Function to remove event listener.\n   */\n  subscribe(e) {\n    return this.subscribeListeners.push(e), () => this.unsubscribe(e);\n  }\n  /**\n   * Removes global event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param listener - event listener.\n   */\n  unsubscribe(e) {\n    for (let s = 0; s < this.subscribeListeners.length; s += 1)\n      if (this.subscribeListeners[s] === e) {\n        this.subscribeListeners.splice(s, 1);\n        return;\n      }\n  }\n}\nfunction G(t, e, s) {\n  return window.addEventListener(t, e, s), () => window.removeEventListener(t, e, s);\n}\nfunction J(...t) {\n  let e = !1;\n  const s = t.flat(1);\n  return [\n    (n) => !e && s.push(n),\n    () => {\n      e || (e = !0, s.forEach((n) => n()));\n    },\n    e\n  ];\n}\nclass V extends Error {\n  constructor(e, s, n) {\n    super(s, { cause: n }), this.type = e, Object.setPrototypeOf(this, V.prototype);\n  }\n}\nfunction f(t, e, s) {\n  return new V(t, e, s);\n}\nconst ze = \"ERR_METHOD_UNSUPPORTED\", je = \"ERR_METHOD_PARAMETER_UNSUPPORTED\", Fe = \"ERR_UNKNOWN_ENV\", Je = \"ERR_INVOKE_CUSTOM_METHOD_RESPONSE\", Qe = \"ERR_TIMED_OUT\", Ye = \"ERR_UNEXPECTED_TYPE\", ce = \"ERR_PARSE\", Ze = \"ERR_NAVIGATION_LIST_EMPTY\", Ke = \"ERR_NAVIGATION_CURSOR_INVALID\", Xt = \"ERR_NAVIGATION_ITEM_INVALID\", es = \"ERR_SSR_INIT\", Xe = \"ERR_INVALID_PATH_BASE\";\nfunction E() {\n  return f(Ye, \"Value has unexpected type\");\n}\nclass D {\n  constructor(e, s, n) {\n    this.parser = e, this.isOptional = s, this.type = n;\n  }\n  /**\n   * Attempts to parse passed value\n   * @param value - value to parse.\n   * @throws {SDKError} ERR_PARSE\n   * @see ERR_PARSE\n   */\n  parse(e) {\n    if (!(this.isOptional && e === void 0))\n      try {\n        return this.parser(e);\n      } catch (s) {\n        throw f(\n          ce,\n          `Unable to parse value${this.type ? ` as ${this.type}` : \"\"}`,\n          s\n        );\n      }\n  }\n  optional() {\n    return this.isOptional = !0, this;\n  }\n}\nfunction S(t, e) {\n  return () => new D(t, !1, e);\n}\nconst b = S((t) => {\n  if (typeof t == \"boolean\")\n    return t;\n  const e = String(t);\n  if (e === \"1\" || e === \"true\")\n    return !0;\n  if (e === \"0\" || e === \"false\")\n    return !1;\n  throw E();\n}, \"boolean\");\nfunction he(t, e) {\n  const s = {};\n  for (const n in t) {\n    const r = t[n];\n    if (!r)\n      continue;\n    let i, o;\n    if (typeof r == \"function\" || \"parse\" in r)\n      i = n, o = typeof r == \"function\" ? r : r.parse.bind(r);\n    else {\n      const { type: a } = r;\n      i = r.from || n, o = typeof a == \"function\" ? a : a.parse.bind(a);\n    }\n    try {\n      const a = o(e(i));\n      a !== void 0 && (s[n] = a);\n    } catch (a) {\n      throw f(ce, `Unable to parse field \"${n}\"`, a);\n    }\n  }\n  return s;\n}\nfunction pe(t) {\n  let e = t;\n  if (typeof e == \"string\" && (e = JSON.parse(e)), typeof e != \"object\" || e === null || Array.isArray(e))\n    throw E();\n  return e;\n}\nfunction g(t, e) {\n  return new D((s) => {\n    const n = pe(s);\n    return he(t, (r) => n[r]);\n  }, !1, e);\n}\nconst y = S((t) => {\n  if (typeof t == \"number\")\n    return t;\n  if (typeof t == \"string\") {\n    const e = Number(t);\n    if (!Number.isNaN(e))\n      return e;\n  }\n  throw E();\n}, \"number\"), p = S((t) => {\n  if (typeof t == \"string\" || typeof t == \"number\")\n    return t.toString();\n  throw E();\n}, \"string\");\nfunction ue(t) {\n  return g({\n    eventType: p(),\n    eventData: (e) => e\n  }).parse(t);\n}\nfunction et() {\n  [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach((t) => {\n    delete window[t];\n  });\n}\nfunction z(t, e) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: t, eventData: e }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nfunction tt() {\n  [\n    [\"TelegramGameProxy_receiveEvent\"],\n    // Windows Phone.\n    [\"TelegramGameProxy\", \"receiveEvent\"],\n    // Desktop.\n    [\"Telegram\", \"WebView\", \"receiveEvent\"]\n    // Android and iOS.\n  ].forEach((t) => {\n    let e = window;\n    t.forEach((s, n, r) => {\n      if (n === r.length - 1) {\n        e[s] = z;\n        return;\n      }\n      s in e || (e[s] = {}), e = e[s];\n    });\n  });\n}\nconst st = {\n  clipboard_text_received: g({\n    req_id: p(),\n    data: (t) => t === null ? t : p().optional().parse(t)\n  }),\n  custom_method_invoked: g({\n    req_id: p(),\n    result: (t) => t,\n    error: p().optional()\n  }),\n  popup_closed: {\n    parse(t) {\n      return g({\n        button_id: (e) => e == null ? void 0 : p().parse(e)\n      }).parse(t ?? {});\n    }\n  },\n  viewport_changed: g({\n    height: y(),\n    width: (t) => t == null ? window.innerWidth : y().parse(t),\n    is_state_stable: b(),\n    is_expanded: b()\n  })\n};\nfunction nt() {\n  const t = new R(), e = new R();\n  e.subscribe((n) => {\n    t.emit(\"event\", { name: n.event, payload: n.args[0] });\n  }), tt();\n  const [, s] = J(\n    // Don't forget to remove created handlers.\n    et,\n    // Add \"resize\" event listener to make sure, we always have fresh viewport information.\n    // Desktop version of Telegram is sometimes not sending the viewport_changed\n    // event. For example, when the MainButton is shown. That's why we should\n    // add our own listener to make sure, viewport information is always fresh.\n    // Issue: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/10\n    G(\"resize\", () => {\n      e.emit(\"viewport_changed\", {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        is_state_stable: !0,\n        is_expanded: !0\n      });\n    }),\n    // Add listener, which handles events sent from the Telegram web application and also events\n    // generated by the local emitEvent function.\n    G(\"message\", (n) => {\n      if (n.source !== window.parent)\n        return;\n      let r;\n      try {\n        r = ue(n.data);\n      } catch {\n        return;\n      }\n      const { eventType: i, eventData: o } = r, a = st[i];\n      try {\n        const h = a ? a.parse(o) : o;\n        e.emit(...h ? [i, h] : [i]);\n      } catch (h) {\n        F.error(\n          `An error occurred processing the \"${i}\" event from the Telegram application.\nPlease, file an issue here:\nhttps://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose`,\n          r,\n          h\n        );\n      }\n    }),\n    // Clear emitters.\n    () => t.clear(),\n    () => e.clear()\n  );\n  return [{\n    on: e.on.bind(e),\n    off: e.off.bind(e),\n    subscribe(n) {\n      return t.on(\"event\", n);\n    },\n    unsubscribe(n) {\n      t.off(\"event\", n);\n    },\n    get count() {\n      return e.count + t.count;\n    }\n  }, s];\n}\nconst [rt, it] = oe(\n  (t) => {\n    const [e, s] = nt(), n = e.off.bind(e);\n    return e.off = (r, i) => {\n      const { count: o } = e;\n      n(r, i), o && !e.count && t();\n    }, [e, s];\n  },\n  ([, t]) => t()\n);\nfunction M() {\n  return rt()[0];\n}\nfunction B(t, e) {\n  M().off(t, e);\n}\nfunction w(t, e, s) {\n  return M().on(t, e, s);\n}\nfunction k(t) {\n  return typeof t == \"object\" && t !== null && !Array.isArray(t);\n}\nfunction ot(t, e) {\n  const s = t.split(\".\"), n = e.split(\".\"), r = Math.max(s.length, n.length);\n  for (let i = 0; i < r; i += 1) {\n    const o = parseInt(s[i] || \"0\", 10), a = parseInt(n[i] || \"0\", 10);\n    if (o !== a)\n      return o > a ? 1 : -1;\n  }\n  return 0;\n}\nfunction _(t, e) {\n  return ot(t, e) <= 0;\n}\nfunction v(t, e, s) {\n  if (typeof s == \"string\") {\n    if (t === \"web_app_open_link\") {\n      if (e === \"try_instant_view\")\n        return _(\"6.4\", s);\n      if (e === \"try_browser\")\n        return _(\"7.6\", s);\n    }\n    if (t === \"web_app_set_header_color\" && e === \"color\")\n      return _(\"6.9\", s);\n    if (t === \"web_app_close\" && e === \"return_back\")\n      return _(\"7.6\", s);\n  }\n  switch (t) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return _(\"6.1\", e);\n    case \"web_app_open_popup\":\n      return _(\"6.2\", e);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return _(\"6.4\", e);\n    case \"web_app_switch_inline_query\":\n      return _(\"6.7\", e);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return _(\"6.9\", e);\n    case \"web_app_setup_settings_button\":\n      return _(\"6.10\", e);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return _(\"7.2\", e);\n    case \"web_app_setup_swipe_behavior\":\n      return _(\"7.7\", e);\n    default:\n      return [\n        \"iframe_ready\",\n        \"iframe_will_reload\",\n        \"web_app_close\",\n        \"web_app_data_send\",\n        \"web_app_expand\",\n        \"web_app_open_link\",\n        \"web_app_ready\",\n        \"web_app_request_theme\",\n        \"web_app_request_viewport\",\n        \"web_app_setup_main_button\",\n        \"web_app_setup_closing_behavior\"\n      ].includes(t);\n  }\n}\nfunction le(t) {\n  return \"external\" in t && k(t.external) && \"notify\" in t.external && typeof t.external.notify == \"function\";\n}\nfunction de(t) {\n  return \"TelegramWebviewProxy\" in t && k(t.TelegramWebviewProxy) && \"postEvent\" in t.TelegramWebviewProxy && typeof t.TelegramWebviewProxy.postEvent == \"function\";\n}\nfunction _e() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nconst at = \"https://web.telegram.org\";\nlet fe = at;\nfunction ts(t) {\n  fe = t;\n}\nfunction ct() {\n  return fe;\n}\nfunction A(t, e, s) {\n  let n = {}, r;\n  if (!e && !s ? n = {} : e && s ? (n = s, r = e) : e && (\"targetOrigin\" in e ? n = e : r = e), Ge(\"Posting event:\", r ? { event: t, data: r } : { event: t }), _e())\n    return window.parent.postMessage(\n      JSON.stringify({ eventType: t, eventData: r }),\n      n.targetOrigin || ct()\n    );\n  if (le(window)) {\n    window.external.notify(JSON.stringify({ eventType: t, eventData: r }));\n    return;\n  }\n  if (de(window)) {\n    window.TelegramWebviewProxy.postEvent(t, JSON.stringify(r));\n    return;\n  }\n  throw f(\n    Fe,\n    \"Unable to determine current environment and possible way to send event. You are probably trying to use Mini Apps method outside the Telegram application environment.\"\n  );\n}\nfunction ht(t) {\n  return (e, s) => {\n    if (!v(e, t))\n      throw f(ze, `Method \"${e}\" is unsupported in Mini Apps version ${t}`);\n    if (k(s) && e === \"web_app_set_header_color\" && \"color\" in s && !v(e, \"color\", t))\n      throw f(\n        je,\n        `Parameter \"color\" of \"${e}\" method is unsupported in Mini Apps version ${t}`\n      );\n    return A(e, s);\n  };\n}\nfunction ge(t) {\n  return ({ req_id: e }) => e === t;\n}\nfunction we(t) {\n  return f(Qe, `Timeout reached: ${t}ms`);\n}\nfunction be(t, e) {\n  return Promise.race([\n    typeof t == \"function\" ? t() : t,\n    new Promise((s, n) => {\n      setTimeout(() => {\n        n(we(e));\n      }, e);\n    })\n  ]);\n}\nasync function d(t) {\n  let e;\n  const s = new Promise((a) => e = a), { event: n, capture: r, timeout: i } = t, [, o] = J(\n    // We need to iterate over all tracked events, and create their event listeners.\n    (Array.isArray(n) ? n : [n]).map((a) => w(a, (h) => {\n      (!r || (Array.isArray(n) ? r({\n        event: a,\n        payload: h\n      }) : r(h))) && e(h);\n    }))\n  );\n  try {\n    return (t.postEvent || A)(t.method, t.params), await (i ? be(s, i) : s);\n  } finally {\n    o();\n  }\n}\nasync function C(t, e, s, n = {}) {\n  const {\n    result: r,\n    error: i\n  } = await d({\n    ...n,\n    method: \"web_app_invoke_custom_method\",\n    event: \"custom_method_invoked\",\n    params: {\n      method: t,\n      params: e,\n      req_id: s\n    },\n    capture: ge(s)\n  });\n  if (i)\n    throw f(Je, i);\n  return r;\n}\nfunction j(...t) {\n  return t.map((e) => {\n    if (typeof e == \"string\")\n      return e;\n    if (k(e))\n      return j(Object.entries(e).map((s) => s[1] && s[0]));\n    if (Array.isArray(e))\n      return j(...e);\n  }).filter(Boolean).join(\" \");\n}\nfunction ss(...t) {\n  return t.reduce((e, s) => (k(s) && Object.entries(s).forEach(([n, r]) => {\n    const i = j(e[n], r);\n    i.length && (e[n] = i);\n  }), e), {});\n}\nfunction Q(t) {\n  return /^#[\\da-f]{6}$/i.test(t);\n}\nfunction pt(t) {\n  return /^#[\\da-f]{3}$/i.test(t);\n}\nfunction me(t) {\n  const e = t.replace(/\\s/g, \"\").toLowerCase();\n  if (Q(e))\n    return e;\n  if (pt(e)) {\n    let n = \"#\";\n    for (let r = 0; r < 3; r += 1)\n      n += e[1 + r].repeat(2);\n    return n;\n  }\n  const s = e.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || e.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!s)\n    throw new Error(`Value \"${t}\" does not satisfy any of known RGB formats.`);\n  return s.slice(1).reduce((n, r) => {\n    const i = parseInt(r, 10).toString(16);\n    return n + (i.length === 1 ? \"0\" : \"\") + i;\n  }, \"#\");\n}\nfunction ye(t) {\n  const e = me(t);\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce((s, n, r) => {\n      const i = parseInt(e.slice(1 + r * 2, 1 + (r + 1) * 2), 16);\n      return s + i * i * n;\n    }, 0)\n  ) < 120;\n}\nclass ut {\n  constructor(e) {\n    c(this, \"ee\", new R());\n    /**\n     * Adds new event listener.\n     */\n    c(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    c(this, \"off\", this.ee.off.bind(this.ee));\n    this.state = e;\n  }\n  /**\n   * Clones current state and returns its copy.\n   */\n  clone() {\n    return { ...this.state };\n  }\n  set(e, s) {\n    Object.entries(typeof e == \"string\" ? { [e]: s } : e).reduce((r, [i, o]) => this.state[i] === o || o === void 0 ? r : (this.state[i] = o, this.ee.emit(`change:${i}`, o), !0), !1) && this.ee.emit(\"change\", this.state);\n  }\n  /**\n   * Returns value by specified key.\n   * @param key - state key.\n   */\n  get(e) {\n    return this.state[e];\n  }\n}\nclass Y {\n  constructor(e) {\n    c(this, \"state\");\n    /**\n     * Gets the state value.\n     */\n    c(this, \"get\");\n    /**\n     * Sets the state value.\n     */\n    c(this, \"set\");\n    /**\n     * Clones the current state.\n     */\n    c(this, \"clone\");\n    this.state = new ut(e), this.set = this.state.set.bind(this.state), this.get = this.state.get.bind(this.state), this.clone = this.state.clone.bind(this.state);\n  }\n}\nfunction ve(t, e) {\n  return (s) => v(e[s], t);\n}\nclass Z extends Y {\n  constructor(s, n, r) {\n    super(s);\n    /**\n     * @returns True, if specified method is supported by the current component.\n     */\n    c(this, \"supports\");\n    this.supports = ve(n, r);\n  }\n}\nclass lt extends Z {\n  constructor(s, n, r) {\n    super({ isVisible: s }, n, {\n      show: \"web_app_setup_back_button\",\n      hide: \"web_app_setup_back_button\"\n    });\n    /**\n     * Adds a new event listener.\n     * @param event - event to listen.\n     * @param listener - listener to add.\n     */\n    c(this, \"on\", (s, n) => s === \"click\" ? w(\"back_button_pressed\", n) : this.state.on(s, n));\n    /**\n     * Removes the event listener.\n     * @param event - event to listen.\n     * @param listener - listener to remove.\n     */\n    c(this, \"off\", (s, n) => s === \"click\" ? B(\"back_button_pressed\", n) : this.state.off(s, n));\n    this.postEvent = r;\n  }\n  set isVisible(s) {\n    this.set(\"isVisible\", s), this.postEvent(\"web_app_setup_back_button\", { is_visible: s });\n  }\n  /**\n   * True if BackButton is currently visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Hides the BackButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the BackButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nconst Ee = S((t) => t instanceof Date ? t : new Date(y().parse(t) * 1e3), \"Date\");\nfunction K(t, e) {\n  return new D((s) => {\n    if (typeof s != \"string\" && !(s instanceof URLSearchParams))\n      throw E();\n    const n = typeof s == \"string\" ? new URLSearchParams(s) : s;\n    return he(t, (r) => {\n      const i = n.get(r);\n      return i === null ? void 0 : i;\n    });\n  }, !1, e);\n}\nconst dt = g({\n  id: y(),\n  type: p(),\n  title: p(),\n  photoUrl: {\n    type: p().optional(),\n    from: \"photo_url\"\n  },\n  username: p().optional()\n}, \"Chat\").optional(), ne = g({\n  addedToAttachmentMenu: {\n    type: b().optional(),\n    from: \"added_to_attachment_menu\"\n  },\n  allowsWriteToPm: {\n    type: b().optional(),\n    from: \"allows_write_to_pm\"\n  },\n  firstName: {\n    type: p(),\n    from: \"first_name\"\n  },\n  id: y(),\n  isBot: {\n    type: b().optional(),\n    from: \"is_bot\"\n  },\n  isPremium: {\n    type: b().optional(),\n    from: \"is_premium\"\n  },\n  languageCode: {\n    type: p().optional(),\n    from: \"language_code\"\n  },\n  lastName: {\n    type: p().optional(),\n    from: \"last_name\"\n  },\n  photoUrl: {\n    type: p().optional(),\n    from: \"photo_url\"\n  },\n  username: p().optional()\n}, \"User\").optional();\nfunction Se() {\n  return K({\n    authDate: {\n      type: Ee(),\n      from: \"auth_date\"\n    },\n    canSendAfter: {\n      type: y().optional(),\n      from: \"can_send_after\"\n    },\n    chat: dt,\n    chatInstance: {\n      type: p().optional(),\n      from: \"chat_instance\"\n    },\n    chatType: {\n      type: p().optional(),\n      from: \"chat_type\"\n    },\n    hash: p(),\n    queryId: {\n      type: p().optional(),\n      from: \"query_id\"\n    },\n    receiver: ne,\n    startParam: {\n      type: p().optional(),\n      from: \"start_param\"\n    },\n    user: ne\n  }, \"InitData\");\n}\nconst _t = S((t) => me(p().parse(t)), \"rgb\");\nfunction ft(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction gt(t) {\n  return t.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nconst xe = S(\n  (t) => {\n    const e = _t().optional();\n    return Object.entries(pe(t)).reduce((s, [n, r]) => (s[ft(n)] = e.parse(r), s), {});\n  },\n  \"ThemeParams\"\n);\nfunction X(t) {\n  return K({\n    botInline: {\n      type: b().optional(),\n      from: \"tgWebAppBotInline\"\n    },\n    initData: {\n      type: Se().optional(),\n      from: \"tgWebAppData\"\n    },\n    initDataRaw: {\n      type: p().optional(),\n      from: \"tgWebAppData\"\n    },\n    platform: {\n      type: p(),\n      from: \"tgWebAppPlatform\"\n    },\n    showSettings: {\n      type: b().optional(),\n      from: \"tgWebAppShowSettings\"\n    },\n    startParam: {\n      type: p().optional(),\n      from: \"tgWebAppStartParam\"\n    },\n    themeParams: {\n      type: xe(),\n      from: \"tgWebAppThemeParams\"\n    },\n    version: {\n      type: p(),\n      from: \"tgWebAppVersion\"\n    }\n  }).parse(t);\n}\nfunction Pe(t) {\n  return X(\n    t.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\")\n  );\n}\nfunction wt() {\n  return Pe(window.location.href);\n}\nfunction Ce() {\n  return performance.getEntriesByType(\"navigation\")[0];\n}\nfunction bt() {\n  const t = Ce();\n  if (!t)\n    throw new Error(\"Unable to get first navigation entry.\");\n  return Pe(t.name);\n}\nfunction Te(t) {\n  return `telegram-apps/${t.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`)}`;\n}\nfunction Re(t, e) {\n  sessionStorage.setItem(Te(t), JSON.stringify(e));\n}\nfunction Ae(t) {\n  const e = sessionStorage.getItem(Te(t));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction mt() {\n  return X(Ae(\"launchParams\") || \"\");\n}\nfunction Ie(t) {\n  return JSON.stringify(\n    Object.fromEntries(\n      Object.entries(t).map(([e, s]) => [gt(e), s])\n    )\n  );\n}\nfunction yt(t) {\n  const {\n    initDataRaw: e,\n    themeParams: s,\n    platform: n,\n    version: r,\n    showSettings: i,\n    startParam: o,\n    botInline: a\n  } = t, h = new URLSearchParams();\n  return h.set(\"tgWebAppPlatform\", n), h.set(\"tgWebAppThemeParams\", Ie(s)), h.set(\"tgWebAppVersion\", r), e && h.set(\"tgWebAppData\", e), o && h.set(\"tgWebAppStartParam\", o), typeof i == \"boolean\" && h.set(\"tgWebAppShowSettings\", i ? \"1\" : \"0\"), typeof a == \"boolean\" && h.set(\"tgWebAppBotInline\", a ? \"1\" : \"0\"), h.toString();\n}\nfunction qe(t) {\n  Re(\"launchParams\", yt(t));\n}\nfunction vt() {\n  for (const t of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed and then page was reloaded.\n    wt,\n    // Then, try using the lower level API - window.performance.\n    bt,\n    // Finally, try to extract launch parameters from the session storage.\n    mt\n  ])\n    try {\n      const e = t();\n      return qe(e), e;\n    } catch {\n    }\n  throw new Error(\"Unable to retrieve launch parameters from any known source.\");\n}\nfunction ke() {\n  const t = Ce();\n  return !!(t && t.type === \"reload\");\n}\nfunction Et() {\n  let t = 0;\n  return () => (t += 1).toString();\n}\nconst [St] = oe(Et);\nfunction l(t, e) {\n  return () => {\n    const s = vt(), n = {\n      ...s,\n      postEvent: ht(s.version),\n      createRequestId: St()\n    };\n    if (typeof t == \"function\")\n      return t(n);\n    const [r, i, o] = J(), a = e({\n      ...n,\n      // State should only be passed only in case, current page was reloaded. If we don't add\n      // this check, state restoration will work improperly in the web version of Telegram,\n      // when we are always working in the same \"session\" (tab).\n      state: ke() ? Ae(t) : void 0,\n      addCleanup: r\n    }), h = (u) => (o || r(\n      u.on(\"change\", ($e) => {\n        Re(t, $e);\n      })\n    ), u);\n    return [\n      a instanceof Promise ? a.then(h) : h(a),\n      i\n    ];\n  };\n}\nconst ns = l(\"backButton\", ({\n  postEvent: t,\n  version: e,\n  state: s = { isVisible: !1 }\n}) => new lt(s.isVisible, e, t));\nclass x extends Z {\n  constructor() {\n    super(...arguments);\n    /**\n     * Adds a new event listener.\n     */\n    c(this, \"on\", this.state.on.bind(this.state));\n    /**\n     * Removes the event listener.\n     */\n    c(this, \"off\", this.state.off.bind(this.state));\n  }\n}\nfunction Ne(t) {\n  const e = t.available ? t : {\n    available: !1,\n    device_id: \"\",\n    token_saved: !1,\n    access_requested: !1,\n    access_granted: !1,\n    type: \"\"\n  };\n  return {\n    available: !0,\n    type: e.type,\n    deviceId: e.device_id,\n    tokenSaved: e.token_saved,\n    accessRequested: e.access_requested,\n    accessGranted: e.access_granted\n  };\n}\nclass xt extends x {\n  constructor({ postEvent: s, version: n, ...r }) {\n    super(r, n, {\n      auth: \"web_app_biometry_request_auth\",\n      openSettings: \"web_app_biometry_open_settings\",\n      requestAccess: \"web_app_biometry_request_access\",\n      updateToken: \"web_app_biometry_update_token\"\n    });\n    c(this, \"postEvent\");\n    c(this, \"authPromise\");\n    c(this, \"accessPromise\");\n    this.postEvent = s;\n  }\n  /**\n   * Shows whether biometry is available.\n   */\n  get available() {\n    return this.get(\"available\");\n  }\n  /**\n   * Shows whether permission to use biometrics has been granted.\n   */\n  get accessGranted() {\n    return this.get(\"accessGranted\");\n  }\n  /**\n   * Shows whether if permission to use biometrics has been requested.\n   */\n  get accessRequested() {\n    return this.get(\"accessRequested\");\n  }\n  /**\n   * Authenticates the user using biometrics.\n   * @param options - method options.\n   * @since 7.2\n   * @returns Token from the local secure storage, if authentication was successful.\n   */\n  async authenticate({\n    reason: s,\n    ...n\n  }) {\n    return this.authPromise || (this.authPromise = d({\n      ...n,\n      method: \"web_app_biometry_request_auth\",\n      event: \"biometry_auth_requested\",\n      postEvent: this.postEvent,\n      params: {\n        // TODO: Check if reason is empty works fine.\n        reason: (s || \"\").trim()\n      }\n    }).then(({ token: r }) => r).finally(() => this.authPromise = void 0)), this.authPromise;\n  }\n  /**\n   * A unique device identifier that can be used to match the token to the device.\n   */\n  get deviceId() {\n    return this.get(\"deviceId\");\n  }\n  /**\n   * Opens the biometric access settings for bots. Useful when you need to request biometrics\n   * access to users who haven't granted it yet.\n   *\n   * _Note that this method can be called only in response to user interaction with the Mini App\n   * interface (e.g. a click inside the Mini App or on the main button)_.\n   * @since 7.2\n   */\n  openSettings() {\n    this.postEvent(\"web_app_biometry_open_settings\");\n  }\n  /**\n   * Requests permission to use biometrics.\n   * @since 7.2\n   * @returns Promise with true, if access was granted.\n   */\n  requestAccess({ reason: s, ...n } = {}) {\n    return this.accessPromise || (this.accessPromise = d({\n      ...n,\n      postEvent: this.postEvent,\n      method: \"web_app_biometry_request_access\",\n      event: \"biometry_info_received\",\n      params: { reason: s || \"\" }\n    }).then((r) => {\n      const i = Ne(r);\n      return this.set(i), i.accessGranted;\n    }).finally(() => this.accessPromise = void 0)), this.accessPromise;\n  }\n  /**\n   * The type of biometrics currently available on the device.\n   */\n  get biometryType() {\n    return this.get(\"biometryType\");\n  }\n  /**\n   * Shows whether token was saved previously in the local secure storage.\n   */\n  get tokenSaved() {\n    return this.get(\"tokenSaved\");\n  }\n  /**\n   * Updates the biometric token in a secure storage on the device.\n   * @returns Promise with `true`, if token was updated.\n   */\n  async updateToken({ token: s, ...n } = {}) {\n    return [\"removed\", \"updated\"].includes(\n      (await d({\n        ...n,\n        postEvent: this.postEvent,\n        method: \"web_app_biometry_update_token\",\n        event: \"biometry_token_updated\",\n        params: { token: s || \"\" }\n      })).status\n    );\n  }\n}\nasync function Pt(t) {\n  return Ne(\n    await d({\n      ...t || {},\n      method: \"web_app_biometry_get_info\",\n      event: \"biometry_info_received\"\n    })\n  );\n}\nconst rs = l(\n  \"biometryManager\",\n  async ({ postEvent: t, version: e, state: s }) => new xt({\n    ...s || v(\"web_app_biometry_get_info\", e) ? s || await Pt({ timeout: 1e3 }) : {\n      available: !1,\n      accessGranted: !1,\n      accessRequested: !1,\n      tokenSaved: !1,\n      deviceId: \"\"\n    },\n    version: e,\n    postEvent: t\n  })\n);\nclass ee extends Y {\n  constructor() {\n    super(...arguments);\n    /**\n     * Adds a new event listener.\n     */\n    c(this, \"on\", this.state.on.bind(this.state));\n    /**\n     * Removes the event listener.\n     */\n    c(this, \"off\", this.state.off.bind(this.state));\n  }\n}\nclass Ct extends ee {\n  constructor(e, s) {\n    super({ isConfirmationNeeded: e }), this.postEvent = s;\n  }\n  set isConfirmationNeeded(e) {\n    this.set(\"isConfirmationNeeded\", e), this.postEvent(\"web_app_setup_closing_behavior\", { need_confirmation: e });\n  }\n  /**\n   * True, if the confirmation dialog should be shown while the user is trying to close\n   * the Mini App.\n   */\n  get isConfirmationNeeded() {\n    return this.get(\"isConfirmationNeeded\");\n  }\n  /**\n   * Disables the confirmation dialog when closing the Mini App.\n   */\n  disableConfirmation() {\n    this.isConfirmationNeeded = !1;\n  }\n  /**\n   * Enables the confirmation dialog when closing the Mini App.\n   */\n  enableConfirmation() {\n    this.isConfirmationNeeded = !0;\n  }\n}\nconst is = l(\n  \"closingBehavior\",\n  ({\n    postEvent: t,\n    state: e = { isConfirmationNeeded: !1 }\n  }) => new Ct(e.isConfirmationNeeded, t)\n);\nclass te {\n  constructor(e, s) {\n    /**\n     * @returns True, if specified method is supported by the current component.\n     */\n    c(this, \"supports\");\n    this.supports = ve(e, s);\n  }\n}\nfunction Tt(t) {\n  if (Array.isArray(t))\n    return t;\n  if (typeof t == \"string\")\n    try {\n      const e = JSON.parse(t);\n      if (Array.isArray(e))\n        return e;\n    } catch {\n    }\n  throw E();\n}\nclass Rt extends D {\n  constructor(s, n, r) {\n    super(Tt, n, r);\n    c(this, \"itemParser\");\n    this.itemParser = typeof s == \"function\" ? s : s.parse.bind(s);\n  }\n  /**\n   * Attempts to parse passed value\n   * @param value - value to parse.\n   * @throws {SDKError} ERR_PARSE\n   * @see ERR_PARSE\n   */\n  parse(s) {\n    const n = super.parse(s);\n    return n === void 0 ? n : n.map(this.itemParser);\n  }\n  of(s) {\n    return this.itemParser = typeof s == \"function\" ? s : s.parse.bind(s), this;\n  }\n}\nfunction At(t) {\n  return new Rt((e) => e, !1, t);\n}\nfunction re(t, e) {\n  return Object.fromEntries(t.map((s) => [s, e]));\n}\nclass It extends te {\n  constructor(e, s, n) {\n    super(e, {\n      delete: \"web_app_invoke_custom_method\",\n      get: \"web_app_invoke_custom_method\",\n      getKeys: \"web_app_invoke_custom_method\",\n      set: \"web_app_invoke_custom_method\"\n    }), this.createRequestId = s, this.postEvent = n;\n  }\n  /**\n   * Deletes specified key or keys from the cloud storage.\n   * @param keyOrKeys - key or keys to delete.\n   * @param options - request execution options.\n   */\n  async delete(e, s = {}) {\n    const n = Array.isArray(e) ? e : [e];\n    n.length && await C(\n      \"deleteStorageValues\",\n      { keys: n },\n      this.createRequestId(),\n      { ...s, postEvent: this.postEvent }\n    );\n  }\n  /**\n   * Returns list of all keys presented in the cloud storage.\n   * @param options - request execution options.\n   */\n  async getKeys(e = {}) {\n    return At().of(p()).parse(\n      await C(\n        \"getStorageKeys\",\n        {},\n        this.createRequestId(),\n        { ...e, postEvent: this.postEvent }\n      )\n    );\n  }\n  async get(e, s = {}) {\n    const n = Array.isArray(e) ? e : [e];\n    if (!n.length)\n      return re(n, \"\");\n    const r = await C(\n      \"getStorageValues\",\n      { keys: n },\n      this.createRequestId(),\n      { ...s, postEvent: this.postEvent }\n    ), i = g(re(n, p()), \"CloudStorageData\").parse(r);\n    return Array.isArray(e) ? i : i[e];\n  }\n  /**\n   * Saves specified value by key.\n   * @param key - storage key.\n   * @param value - storage value.\n   * @param options - request execution options.\n   */\n  async set(e, s, n = {}) {\n    await C(\n      \"saveStorageValue\",\n      { key: e, value: s },\n      this.createRequestId(),\n      { ...n, postEvent: this.postEvent }\n    );\n  }\n}\nconst os = l(\n  ({ createRequestId: t, postEvent: e, version: s }) => new It(s, t, e)\n);\nclass qt extends te {\n  constructor(e, s) {\n    super(e, {\n      impactOccurred: \"web_app_trigger_haptic_feedback\",\n      notificationOccurred: \"web_app_trigger_haptic_feedback\",\n      selectionChanged: \"web_app_trigger_haptic_feedback\"\n    }), this.postEvent = s;\n  }\n  /**\n   * A method tells that an impact occurred. The Telegram app may play the\n   * appropriate haptics based on style value passed.\n   * @param style - impact style.\n   */\n  impactOccurred(e) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"impact\",\n      impact_style: e\n    });\n  }\n  /**\n   * A method tells that a task or action has succeeded, failed, or produced\n   * a warning. The Telegram app may play the appropriate haptics based on\n   * type value passed.\n   * @param type - notification type.\n   */\n  notificationOccurred(e) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"notification\",\n      notification_type: e\n    });\n  }\n  /**\n   * A method tells that the user has changed a selection. The Telegram app\n   * may play the appropriate haptics.\n   *\n   * Do not use this feedback when the user makes or confirms a selection;\n   * use it only when the selection changes.\n   */\n  selectionChanged() {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", { type: \"selection_change\" });\n  }\n}\nconst as = l(\n  ({ version: t, postEvent: e }) => new qt(t, e)\n);\nclass kt {\n  constructor(e) {\n    this.initData = e;\n  }\n  /**\n   * @see InitDataParsed.authDate\n   */\n  get authDate() {\n    return this.initData.authDate;\n  }\n  /**\n   * @see InitDataParsed.canSendAfter\n   */\n  get canSendAfter() {\n    return this.initData.canSendAfter;\n  }\n  /**\n   * Date after which it is allowed to call\n   * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n   */\n  get canSendAfterDate() {\n    const { canSendAfter: e } = this;\n    return e ? new Date(this.authDate.getTime() + e * 1e3) : void 0;\n  }\n  /**\n   * @see InitDataParsed.chat\n   */\n  get chat() {\n    return this.initData.chat;\n  }\n  /**\n   * @see InitDataParsed.chatType\n   */\n  get chatType() {\n    return this.initData.chatType;\n  }\n  /**\n   * @see InitDataParsed.chatInstance\n   */\n  get chatInstance() {\n    return this.initData.chatInstance;\n  }\n  /**\n   * @see InitDataParsed.hash\n   */\n  get hash() {\n    return this.initData.hash;\n  }\n  /**\n   * @see InitDataParsed.queryId\n   */\n  get queryId() {\n    return this.initData.queryId;\n  }\n  /**\n   * @see InitDataParsed.receiver\n   */\n  get receiver() {\n    return this.initData.receiver;\n  }\n  /**\n   * @see InitDataParsed.startParam\n   */\n  get startParam() {\n    return this.initData.startParam;\n  }\n  /**\n   * @see InitDataParsed.user\n   */\n  get user() {\n    return this.initData.user;\n  }\n}\nconst cs = l(\n  ({ initData: t }) => t ? new kt(t) : void 0\n);\nfunction hs(t) {\n  return Se().parse(t);\n}\nclass Nt extends x {\n  constructor(e, s, n) {\n    super({ isOpened: e }, s, { open: \"web_app_open_invoice\" }), this.postEvent = n;\n  }\n  set isOpened(e) {\n    this.set(\"isOpened\", e);\n  }\n  /**\n   * True if invoice is currently opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  async open(e, s) {\n    if (this.isOpened)\n      throw new Error(\"Invoice is already opened\");\n    let n;\n    if (!s)\n      n = e;\n    else {\n      const { hostname: r, pathname: i } = new URL(e, window.location.href);\n      if (r !== \"t.me\")\n        throw new Error(`Incorrect hostname: ${r}`);\n      const o = i.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n      if (!o)\n        throw new Error('Link pathname has incorrect format. Expected to receive \"/invoice/{slug}\" or \"/${slug}\"');\n      [, , n] = o;\n    }\n    this.isOpened = !0;\n    try {\n      return (await d({\n        method: \"web_app_open_invoice\",\n        event: \"invoice_closed\",\n        params: { slug: n },\n        postEvent: this.postEvent,\n        capture(i) {\n          return n === i.slug;\n        }\n      })).status;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nconst ps = l(\n  ({ version: t, postEvent: e }) => new Nt(!1, t, e)\n);\nclass Vt extends Y {\n  constructor({ postEvent: s, ...n }) {\n    super(n);\n    c(this, \"postEvent\");\n    /**\n     * Adds a new event listener.\n     * @param event - event to listen.\n     * @param listener - listener to add.\n     */\n    c(this, \"on\", (s, n) => s === \"click\" ? w(\"main_button_pressed\", n) : this.state.on(s, n));\n    /**\n     * Removes the event listener.\n     * @param event - event to listen.\n     * @param listener - listener to remove.\n     */\n    c(this, \"off\", (s, n) => s === \"click\" ? B(\"main_button_pressed\", n) : this.state.off(s, n));\n    this.postEvent = s;\n  }\n  /**\n   * The MainButton background color.\n   */\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  /**\n   * Sends current local state to the Telegram application.\n   */\n  commit() {\n    this.text !== \"\" && this.postEvent(\"web_app_setup_main_button\", {\n      is_visible: this.isVisible,\n      is_active: this.isEnabled,\n      is_progress_visible: this.isLoaderVisible,\n      text: this.text,\n      color: this.bgColor,\n      text_color: this.textColor\n    });\n  }\n  /**\n   * Disables the MainButton.\n   * @see Does not work on Android: https://github.com/Telegram-Mini-Apps/issues/issues/1\n   */\n  disable() {\n    return this.isEnabled = !1, this;\n  }\n  /**\n   * Enables the MainButton.\n   */\n  enable() {\n    return this.isEnabled = !0, this;\n  }\n  /**\n   * Hides the MainButton.\n   */\n  hide() {\n    return this.isVisible = !1, this;\n  }\n  /**\n   * Hides the MainButton loading indicator.\n   */\n  hideLoader() {\n    return this.isLoaderVisible = !1, this;\n  }\n  set isEnabled(s) {\n    this.setParams({ isEnabled: s });\n  }\n  /**\n   * True if the MainButton is enabled.\n   */\n  get isEnabled() {\n    return this.get(\"isEnabled\");\n  }\n  set isLoaderVisible(s) {\n    this.setParams({ isLoaderVisible: s });\n  }\n  /**\n   * True if the MainButton loader is visible.\n   */\n  get isLoaderVisible() {\n    return this.get(\"isLoaderVisible\");\n  }\n  set isVisible(s) {\n    this.setParams({ isVisible: s });\n  }\n  /**\n   * True if the MainButton is visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Shows the MainButton.\n   *\n   * Note that opening the Mini App from the attachment menu hides the main button until the\n   * user interacts with the Mini App interface.\n   */\n  show() {\n    return this.isVisible = !0, this;\n  }\n  /**\n   * Shows a loading indicator on the Main Button.\n   */\n  showLoader() {\n    return this.isLoaderVisible = !0, this;\n  }\n  /**\n   * Sets a new MainButton text. Minimal length for the text is 1 symbol, and maximum is 64 symbols.\n   * @param text - a new text.\n   */\n  setText(s) {\n    return this.setParams({ text: s });\n  }\n  /**\n   * Sets a new Main Button text color.\n   * @param textColor - new text color.\n   */\n  setTextColor(s) {\n    return this.setParams({ textColor: s });\n  }\n  /**\n   * Updates current Main Button color.\n   * @param bgColor - color to set.\n   */\n  setBgColor(s) {\n    return this.setParams({ bgColor: s });\n  }\n  /**\n   * Allows setting multiple Main Button parameters.\n   * @param params - Main Button parameters.\n   */\n  setParams(s) {\n    return this.set(s), this.commit(), this;\n  }\n  /**\n   * The MainButton text.\n   */\n  get text() {\n    return this.get(\"text\");\n  }\n  /**\n   * The MainButton text color.\n   */\n  get textColor() {\n    return this.get(\"textColor\");\n  }\n}\nconst us = l(\n  \"mainButton\",\n  ({\n    postEvent: t,\n    themeParams: e,\n    state: s = {\n      isVisible: !1,\n      isEnabled: !1,\n      text: \"\",\n      isLoaderVisible: !1,\n      textColor: e.buttonTextColor || \"#ffffff\",\n      bgColor: e.buttonColor || \"#000000\"\n    }\n  }) => new Vt({ ...s, postEvent: t })\n);\nfunction Dt() {\n  return K({\n    contact: g({\n      userId: {\n        type: y(),\n        from: \"user_id\"\n      },\n      phoneNumber: {\n        type: p(),\n        from: \"phone_number\"\n      },\n      firstName: {\n        type: p(),\n        from: \"first_name\"\n      },\n      lastName: {\n        type: p().optional(),\n        from: \"last_name\"\n      }\n    }),\n    authDate: {\n      type: Ee(),\n      from: \"auth_date\"\n    },\n    hash: p()\n  }, \"RequestedContact\");\n}\nfunction Ve(t, e) {\n  return (s) => {\n    const [n, r] = e[s];\n    return v(n, r, t);\n  };\n}\nfunction Mt(t) {\n  return new Promise((e) => {\n    setTimeout(e, t);\n  });\n}\nclass Bt extends x {\n  constructor({ postEvent: s, createRequestId: n, version: r, botInline: i, ...o }) {\n    super(o, r, {\n      requestPhoneAccess: \"web_app_request_phone\",\n      requestWriteAccess: \"web_app_request_write_access\",\n      switchInlineQuery: \"web_app_switch_inline_query\",\n      setHeaderColor: \"web_app_set_header_color\",\n      setBackgroundColor: \"web_app_set_background_color\"\n    });\n    c(this, \"botInline\");\n    c(this, \"postEvent\");\n    c(this, \"createRequestId\");\n    c(this, \"requestPhoneAccessPromise\");\n    c(this, \"requestWriteAccessPromise\");\n    /**\n     * Checks if specified method parameter is supported by current component.\n     */\n    c(this, \"supportsParam\");\n    this.createRequestId = n, this.postEvent = s, this.botInline = i;\n    const a = this.supports.bind(this);\n    this.supports = (h) => a(h) ? h !== \"switchInlineQuery\" || i : !1, this.supportsParam = Ve(r, {\n      \"setHeaderColor.color\": [\"web_app_set_header_color\", \"color\"],\n      \"close.returnBack\": [\"web_app_close\", \"return_back\"]\n    });\n  }\n  /**\n   * Attempts to get requested contact.\n   * @param timeout - request timeout.\n   */\n  async getRequestedContact({\n    timeout: s = 1e4\n  } = {}) {\n    return Dt().parse(\n      await C(\n        \"getRequestedContact\",\n        {},\n        this.createRequestId(),\n        { postEvent: this.postEvent, timeout: s }\n      )\n    );\n  }\n  /**\n   * The Mini App background color.\n   * @example \"#ffaabb\"\n   */\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  /**\n   * Closes the Mini App.\n   * @param returnBack - should the application be wrapped into the bottom bar.\n   */\n  close(s) {\n    this.postEvent(\"web_app_close\", this.supportsParam(\"close.returnBack\") ? { return_back: s } : {});\n  }\n  /**\n   * The Mini App header color.\n   * @example \"#ffaabb\"\n   * @example \"bg_color\"\n   */\n  get headerColor() {\n    return this.get(\"headerColor\");\n  }\n  /**\n   * True if the Mini App is currently launched in bot inline mode.\n   */\n  get isBotInline() {\n    return this.botInline;\n  }\n  /**\n   * True if the current Mini App background color is recognized as dark.\n   */\n  get isDark() {\n    return ye(this.bgColor);\n  }\n  /**\n   * Informs the Telegram app that the Mini App is ready to be displayed.\n   *\n   * It is recommended to call this method as early as possible, as soon as all essential\n   * interface elements loaded. Once this method called, the loading placeholder is hidden\n   * and the Mini App shown.\n   *\n   * If the method not called, the placeholder will be hidden only when the page fully loaded.\n   */\n  ready() {\n    this.postEvent(\"web_app_ready\");\n  }\n  /**\n   * Requests current user contact information. In contrary to requestPhoneAccess, this method\n   * returns promise with contact information that rejects in case, user denied access, or request\n   * failed.\n   * @param options - additional options.\n   */\n  async requestContact({ timeout: s = 5e3 } = {}) {\n    try {\n      return await this.getRequestedContact();\n    } catch {\n    }\n    if (await this.requestPhoneAccess() !== \"sent\")\n      throw new Error(\"Access denied.\");\n    const r = Date.now() + s;\n    let i = 50;\n    return be(async () => {\n      for (; Date.now() < r; ) {\n        try {\n          return await this.getRequestedContact();\n        } catch {\n        }\n        await Mt(i), i += 50;\n      }\n      throw we(s);\n    }, s);\n  }\n  /**\n   * Requests current user phone access. Method returns promise, which resolves\n   * status of the request. In case, user accepted the request, Mini App bot will receive\n   * the according notification.\n   *\n   * To obtain the retrieved information instead, utilize the `requestContact` method.\n   * @param options - additional options.\n   * @see requestContact\n   */\n  async requestPhoneAccess(s = {}) {\n    return this.requestPhoneAccessPromise || (this.requestPhoneAccessPromise = d({\n      ...s,\n      method: \"web_app_request_phone\",\n      event: \"phone_requested\",\n      postEvent: this.postEvent\n    }).then(({ status: n }) => n).finally(() => this.requestPhoneAccessPromise = void 0)), this.requestPhoneAccessPromise;\n  }\n  /**\n   * Requests write message access to current user.\n   * @param options - additional options.\n   */\n  async requestWriteAccess(s = {}) {\n    return this.requestWriteAccessPromise || (this.requestWriteAccessPromise = d({\n      ...s,\n      method: \"web_app_request_write_access\",\n      event: \"write_access_requested\",\n      postEvent: this.postEvent\n    }).then(({ status: n }) => n).finally(() => this.requestWriteAccessPromise = void 0)), this.requestWriteAccessPromise;\n  }\n  /**\n   * A method used to send data to the bot. When this method called, a service message sent to\n   * the bot containing the data of the length up to 4096 bytes, and the Mini App closed. See the\n   * field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n   *\n   * This method is only available for Mini Apps launched via a Keyboard button.\n   * @param data - data to send to bot.\n   * @throws {Error} data has incorrect size.\n   */\n  sendData(s) {\n    const { size: n } = new Blob([s]);\n    if (!n || n > 4096)\n      throw new Error(`Passed data has incorrect size: ${n}`);\n    this.postEvent(\"web_app_data_send\", { data: s });\n  }\n  /**\n   * Updates current Mini App header color.\n   *\n   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/9\n   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/8\n   * @param color - color key or RGB color.\n   */\n  setHeaderColor(s) {\n    this.postEvent(\"web_app_set_header_color\", Q(s) ? { color: s } : { color_key: s }), this.set(\"headerColor\", s);\n  }\n  /**\n   * Updates current Mini App background color.\n   *\n   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/9\n   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/8\n   * @param color - RGB color.\n   */\n  setBgColor(s) {\n    this.postEvent(\"web_app_set_background_color\", { color: s }), this.set(\"bgColor\", s);\n  }\n  /**\n   * Inserts the bot's username and the specified inline query in the current chat's input field.\n   * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n   * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n   * the specified inline query in the input field.\n   * @param text - text which should be inserted in the input after the current bot name. Max\n   * length is 256 symbols.\n   * @param chatTypes - List of chat types which could be chosen to send the message. Could be\n   * empty list.\n   */\n  switchInlineQuery(s, n = []) {\n    if (!this.supports(\"switchInlineQuery\") && !this.isBotInline)\n      throw new Error(\"Method is unsupported because Mini App should be launched in inline mode.\");\n    this.postEvent(\"web_app_switch_inline_query\", { query: s, chat_types: n });\n  }\n}\nconst ls = l(\n  \"miniApp\",\n  ({\n    themeParams: t,\n    botInline: e = !1,\n    state: s = {\n      bgColor: t.bgColor || \"#ffffff\",\n      headerColor: t.headerBgColor || \"#000000\"\n    },\n    ...n\n  }) => new Bt({ ...n, ...s, botInline: e })\n);\nfunction Lt(t) {\n  const e = t.message.trim(), s = (t.title || \"\").trim(), n = t.buttons || [];\n  let r;\n  if (s.length > 64)\n    throw new Error(`Title has incorrect size: ${s.length}`);\n  if (!e.length || e.length > 256)\n    throw new Error(`Message has incorrect size: ${e.length}`);\n  if (n.length > 3)\n    throw new Error(`Buttons have incorrect size: ${n.length}`);\n  return n.length ? r = n.map((i) => {\n    const { id: o = \"\" } = i;\n    if (o.length > 64)\n      throw new Error(`Button ID has incorrect size: ${o}`);\n    if (!i.type || i.type === \"default\" || i.type === \"destructive\") {\n      const a = i.text.trim();\n      if (!a.length || a.length > 64) {\n        const h = i.type || \"default\";\n        throw new Error(`Button text with type \"${h}\" has incorrect size: ${i.text.length}`);\n      }\n      return { ...i, text: a, id: o };\n    }\n    return { ...i, id: o };\n  }) : r = [{ type: \"close\", id: \"\" }], { title: s, message: e, buttons: r };\n}\nclass $t extends x {\n  constructor(e, s, n) {\n    super({ isOpened: e }, s, { open: \"web_app_open_popup\" }), this.postEvent = n;\n  }\n  set isOpened(e) {\n    this.set(\"isOpened\", e);\n  }\n  /**\n   * True if the Popup is opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  /**\n   * A method that shows a native popup described by the `params` argument.\n   * Promise will be resolved when popup is closed. Resolved value will have\n   * an identifier of pressed button.\n   *\n   * In case, user clicked outside the popup or clicked top right popup close\n   * button, null will be returned.\n   *\n   * @param options - popup parameters.\n   * @throws {Error} Popup is already opened.\n   */\n  async open(e) {\n    if (this.isOpened)\n      throw new Error(\"Popup is already opened.\");\n    this.isOpened = !0;\n    try {\n      const { button_id: s = null } = await d({\n        event: \"popup_closed\",\n        method: \"web_app_open_popup\",\n        postEvent: this.postEvent,\n        params: Lt(e)\n      });\n      return s;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nconst ds = l(\n  ({ postEvent: t, version: e }) => new $t(!1, e, t)\n);\nclass Wt extends x {\n  constructor(e, s, n) {\n    super({ isOpened: e }, s, {\n      close: \"web_app_close_scan_qr_popup\",\n      open: \"web_app_open_scan_qr_popup\"\n    }), this.postEvent = n;\n  }\n  /**\n   * Closes the scanner.\n   */\n  close() {\n    this.postEvent(\"web_app_close_scan_qr_popup\"), this.isOpened = !1;\n  }\n  set isOpened(e) {\n    this.set(\"isOpened\", e);\n  }\n  /**\n   * Returns true if the scanner is currently opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  async open(e) {\n    if (this.isOpened)\n      throw new Error(\"The scanner is already opened\");\n    const { text: s, capture: n } = (typeof e == \"string\" ? { text: e } : e) || {};\n    this.isOpened = !0;\n    try {\n      const i = (await d({\n        method: \"web_app_open_scan_qr_popup\",\n        event: [\"qr_text_received\", \"scan_qr_popup_closed\"],\n        postEvent: this.postEvent,\n        params: { text: s },\n        capture(o) {\n          return o.event === \"scan_qr_popup_closed\" || !n || n(o.payload);\n        }\n      }) || {}).data || null;\n      return i && this.close(), i;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n  // TODO: Streaming mode, allowing to scan several QRs until closed.\n}\nconst _s = l(\n  ({ version: t, postEvent: e }) => new Wt(!1, t, e)\n);\nclass Ut extends Z {\n  constructor(s, n, r) {\n    super({ isVisible: s }, n, {\n      show: \"web_app_setup_settings_button\",\n      hide: \"web_app_setup_settings_button\"\n    });\n    /**\n     * Adds a new event listener.\n     * @param event - event to listen.\n     * @param listener - listener to add.\n     */\n    c(this, \"on\", (s, n) => s === \"click\" ? w(\"settings_button_pressed\", n) : this.state.on(s, n));\n    /**\n     * Removes the event listener.\n     * @param event - event to listen.\n     * @param listener - listener to remove.\n     */\n    c(this, \"off\", (s, n) => s === \"click\" ? B(\"settings_button_pressed\", n) : this.state.off(s, n));\n    this.postEvent = r;\n  }\n  set isVisible(s) {\n    this.set(\"isVisible\", s), this.postEvent(\"web_app_setup_settings_button\", { is_visible: s });\n  }\n  /**\n   * True if the SettingsButton is visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Hides the SettingsButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the SettingsButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nconst fs = l(\n  \"settingsButton\",\n  ({\n    version: t,\n    postEvent: e,\n    state: s = { isVisible: !1 }\n  }) => new Ut(s.isVisible, t, e)\n);\nclass Ht extends x {\n  constructor(e, s, n) {\n    super({ isVerticalSwipeEnabled: e }, s, {\n      disableVerticalSwipe: \"web_app_setup_swipe_behavior\",\n      enableVerticalSwipe: \"web_app_setup_swipe_behavior\"\n    }), this.postEvent = n;\n  }\n  set isVerticalSwipeEnabled(e) {\n    this.set(\"isVerticalSwipeEnabled\", e), this.postEvent(\"web_app_setup_swipe_behavior\", { allow_vertical_swipe: e });\n  }\n  /**\n   * True, if the vertical swipe enabled.\n   */\n  get isVerticalSwipeEnabled() {\n    return this.get(\"isVerticalSwipeEnabled\");\n  }\n  /**\n   * Disables the vertical swipe.\n   */\n  disableVerticalSwipe() {\n    this.isVerticalSwipeEnabled = !1;\n  }\n  /**\n   * Enables the vertical swipe.\n   */\n  enableVerticalSwipe() {\n    this.isVerticalSwipeEnabled = !0;\n  }\n}\nconst gs = l(\n  \"swipeBehavior\",\n  ({\n    postEvent: t,\n    state: e = { isVerticalSwipeEnabled: !0 },\n    version: s\n  }) => new Ht(e.isVerticalSwipeEnabled, s, t)\n);\nfunction De(t) {\n  return xe().parse(t);\n}\nclass Ot extends ee {\n  /**\n   * @since v6.10\n   */\n  get accentTextColor() {\n    return this.get(\"accentTextColor\");\n  }\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  get buttonColor() {\n    return this.get(\"buttonColor\");\n  }\n  get buttonTextColor() {\n    return this.get(\"buttonTextColor\");\n  }\n  get destructiveTextColor() {\n    return this.get(\"destructiveTextColor\");\n  }\n  /**\n   * Returns the copy of the internal state of the current component instance.\n   */\n  getState() {\n    return this.clone();\n  }\n  /**\n   * @since v6.10\n   */\n  get headerBgColor() {\n    return this.get(\"headerBgColor\");\n  }\n  get hintColor() {\n    return this.get(\"hintColor\");\n  }\n  /**\n   * @returns True in case, current color scheme is recognized as dark. This\n   * value is calculated according to theme bg color.\n   */\n  get isDark() {\n    return !this.bgColor || ye(this.bgColor);\n  }\n  get linkColor() {\n    return this.get(\"linkColor\");\n  }\n  get secondaryBgColor() {\n    return this.get(\"secondaryBgColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionBgColor() {\n    return this.get(\"sectionBgColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionHeaderTextColor() {\n    return this.get(\"sectionHeaderTextColor\");\n  }\n  /**\n   * @since v7.6\n   */\n  get sectionSeparatorColor() {\n    return this.get(\"sectionHeaderTextColor\");\n  }\n  /**\n   * Starts listening to the external theme changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return w(\"theme_changed\", (e) => {\n      this.set(De(e.theme_params));\n    });\n  }\n  /**\n   * @since v6.10\n   */\n  get subtitleTextColor() {\n    return this.get(\"subtitleTextColor\");\n  }\n  get textColor() {\n    return this.get(\"textColor\");\n  }\n}\nconst ws = l(\n  \"themeParams\",\n  ({ themeParams: t, state: e = t, addCleanup: s }) => {\n    const n = new Ot(e);\n    return s(n.listen()), n;\n  }\n);\nfunction bs(t = {}) {\n  return d({\n    ...t,\n    method: \"web_app_request_theme\",\n    event: \"theme_changed\"\n  }).then(De);\n}\nfunction I(t, e) {\n  return t.startsWith(e) ? t : `${e}${t}`;\n}\nfunction q(t) {\n  return new URL(\n    typeof t == \"string\" ? t : `${t.pathname || \"\"}${I(t.search || \"\", \"?\")}${I(t.hash || \"\", \"#\")}`,\n    \"http://a\"\n  );\n}\nclass Gt extends te {\n  constructor(s, n, r) {\n    super(s, { readTextFromClipboard: \"web_app_read_text_from_clipboard\" });\n    /**\n     * Checks if specified method parameter is supported by current component.\n     */\n    c(this, \"supportsParam\");\n    this.version = s, this.createRequestId = n, this.postEvent = r, this.supportsParam = Ve(s, {\n      \"openLink.tryInstantView\": [\"web_app_open_link\", \"try_instant_view\"]\n    });\n  }\n  openLink(s, n) {\n    const r = q(s).toString();\n    if (!v(\"web_app_open_link\", this.version)) {\n      window.open(r, \"_blank\");\n      return;\n    }\n    const i = typeof n == \"boolean\" ? { tryInstantView: n } : n || {};\n    this.postEvent(\"web_app_open_link\", {\n      url: r,\n      try_browser: i.tryBrowser,\n      try_instant_view: i.tryInstantView\n    });\n  }\n  /**\n   * Opens a Telegram link inside Telegram app. The Mini App will be closed. It expects passing\n   * link in full format, with hostname \"t.me\".\n   * @param url - URL to be opened.\n   * @throws {Error} URL has not allowed hostname.\n   */\n  openTelegramLink(s) {\n    const { hostname: n, pathname: r, search: i } = new URL(s, \"https://t.me\");\n    if (n !== \"t.me\")\n      throw new Error(`URL has not allowed hostname: ${n}. Only \"t.me\" is allowed`);\n    if (!v(\"web_app_open_tg_link\", this.version)) {\n      window.location.href = s;\n      return;\n    }\n    this.postEvent(\"web_app_open_tg_link\", { path_full: r + i });\n  }\n  /**\n   * Reads text from clipboard and returns string or null. null is returned\n   * in cases:\n   * - Value in clipboard is not text\n   * - Access to clipboard is not allowed\n   */\n  async readTextFromClipboard() {\n    const s = this.createRequestId(), {\n      data: n = null\n    } = await d({\n      method: \"web_app_read_text_from_clipboard\",\n      event: \"clipboard_text_received\",\n      postEvent: this.postEvent,\n      params: { req_id: s },\n      capture: ge(s)\n    });\n    return n;\n  }\n  /**\n   * Shares specified URL with the passed to the chats, selected by user. After being called,\n   * it closes the mini application.\n   *\n   * This method uses Telegram's Share Links.\n   * @param url - URL to share.\n   * @param text - text to append after the URL.\n   * @see https://core.telegram.org/api/links#share-links\n   * @see https://core.telegram.org/widgets/share#custom-buttons\n   */\n  shareURL(s, n) {\n    this.openTelegramLink(\n      \"https://t.me/share/url?\" + new URLSearchParams({ url: s, text: n || \"\" }).toString().replace(/\\+/g, \"%20\")\n    );\n  }\n}\nconst ms = l(\n  ({ version: t, postEvent: e, createRequestId: s }) => new Gt(t, s, e)\n);\nasync function Me(t = {}) {\n  const {\n    is_expanded: e,\n    is_state_stable: s,\n    ...n\n  } = await d({\n    ...t,\n    method: \"web_app_request_viewport\",\n    event: \"viewport_changed\"\n  });\n  return { ...n, isExpanded: e, isStateStable: s };\n}\nfunction P(t) {\n  return t < 0 ? 0 : t;\n}\nclass zt extends ee {\n  constructor({ postEvent: s, stableHeight: n, height: r, width: i, isExpanded: o }) {\n    super({\n      height: P(r),\n      isExpanded: o,\n      stableHeight: P(n),\n      width: P(i)\n    });\n    c(this, \"postEvent\");\n    this.postEvent = s;\n  }\n  /**\n   * Requests viewport information from the Telegram application and updates current Viewport\n   * instance.\n   * @param options - options to request fresh data.\n   */\n  async sync(s) {\n    const { isStateStable: n, ...r } = await Me(s);\n    this.set({\n      ...r,\n      stableHeight: n ? r.height : this.get(\"stableHeight\")\n    });\n  }\n  /**\n   * The current height of the **visible area** of the Mini App.\n   *\n   * The application can display just the top part of the Mini App, with its lower part remaining\n   * outside the screen area. From this position, the user can \"pull\" the Mini App to its\n   * maximum height, while the bot can do the same by calling `expand` method. As the position of\n   * the Mini App changes, the current height value of the visible area will be updated  in real\n   * time.\n   *\n   * Please note that the refresh rate of this value is not sufficient to smoothly follow the\n   * lower border of the window. It should not be used to pin interface elements to the bottom\n   * of the visible area. It's more appropriate to use the value of the `stableHeight`\n   * field for this purpose.\n   *\n   * @see stableHeight\n   */\n  get height() {\n    return this.get(\"height\");\n  }\n  /**\n   * The height of the visible area of the Mini App in its last stable state.\n   *\n   * The application can display just the top part of the Mini App, with its lower part remaining\n   * outside the screen area. From this position, the user can \"pull\" the Mini App to its\n   * maximum height, while the application can do the same by calling `expand` method.\n   *\n   * Unlike the value of `height`, the value of `stableHeight` does not change as the position\n   * of the Mini App changes with user gestures or during animations. The value of `stableHeight`\n   * will be updated after all gestures and animations are completed and\n   * the Mini App reaches its final size.\n   *\n   * @see height\n   */\n  get stableHeight() {\n    return this.get(\"stableHeight\");\n  }\n  /**\n   * Starts listening to viewport changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return w(\"viewport_changed\", (s) => {\n      const {\n        height: n,\n        width: r,\n        is_expanded: i,\n        is_state_stable: o\n      } = s, a = P(n);\n      this.set({\n        height: a,\n        isExpanded: i,\n        width: P(r),\n        ...o ? { stableHeight: a } : {}\n      });\n    });\n  }\n  /**\n   * True if the Mini App is expanded to the maximum available height. Otherwise, if\n   * the Mini App occupies part of the screen and can be expanded to the full height using\n   * `expand` method.\n   * @see expand\n   */\n  get isExpanded() {\n    return this.get(\"isExpanded\");\n  }\n  /**\n   * Current visible area width.\n   */\n  get width() {\n    return this.get(\"width\");\n  }\n  /**\n   * A method that expands the Mini App to the maximum available height. To find out if the Mini\n   * App is expanded to the maximum height, refer to the value of the `isExpanded`.\n   * @see isExpanded\n   */\n  expand() {\n    this.postEvent(\"web_app_expand\"), this.set(\"isExpanded\", !0);\n  }\n  /**\n   * True if the current viewport height is stable and is not going to change in the next moment.\n   */\n  get isStable() {\n    return this.stableHeight === this.height;\n  }\n}\nconst ys = l(\n  \"viewport\",\n  async ({ state: t, platform: e, postEvent: s, addCleanup: n }) => {\n    let r = !1, i = 0, o = 0, a = 0;\n    if (t)\n      r = t.isExpanded, i = t.height, o = t.width, a = t.stableHeight;\n    else if ([\"macos\", \"tdesktop\", \"unigram\", \"webk\", \"weba\", \"web\"].includes(e))\n      r = !0, i = window.innerHeight, o = window.innerWidth, a = window.innerHeight;\n    else {\n      const u = await Me({ timeout: 1e3, postEvent: s });\n      r = u.isExpanded, i = u.height, o = u.width, a = u.isStateStable ? i : 0;\n    }\n    const h = new zt({\n      postEvent: s,\n      height: i,\n      width: o,\n      stableHeight: a,\n      isExpanded: r\n    });\n    return n(h.listen()), h;\n  }\n);\nfunction m(t, e) {\n  document.documentElement.style.setProperty(t, e);\n}\nfunction vs(t, e, s) {\n  s || (s = (a) => `--tg-${a}-color`);\n  const n = s(\"header\"), r = s(\"bg\"), i = () => {\n    const { headerColor: a } = t;\n    if (Q(a))\n      m(n, a);\n    else {\n      const { bgColor: h, secondaryBgColor: u } = e;\n      a === \"bg_color\" && h ? m(n, h) : a === \"secondary_bg_color\" && u && m(n, u);\n    }\n    m(r, t.bgColor);\n  }, o = [\n    e.on(\"change\", i),\n    t.on(\"change\", i)\n  ];\n  return i(), () => o.forEach((a) => a());\n}\nfunction Es(t, e) {\n  e || (e = (n) => `--tg-theme-${n.replace(/[A-Z]/g, (r) => `-${r.toLowerCase()}`)}`);\n  const s = () => {\n    Object.entries(t.getState()).forEach(([n, r]) => {\n      r && m(e(n), r);\n    });\n  };\n  return s(), t.on(\"change\", s);\n}\nfunction Ss(t, e) {\n  e || (e = (u) => `--tg-viewport-${u}`);\n  const [\n    s,\n    n,\n    r\n  ] = [\"height\", \"width\", \"stable-height\"].map((u) => e(u)), i = () => m(s, `${t.height}px`), o = () => m(n, `${t.width}px`), a = () => m(r, `${t.stableHeight}px`), h = [\n    t.on(\"change:height\", i),\n    t.on(\"change:width\", o),\n    t.on(\"change:stableHeight\", a)\n  ];\n  return i(), o(), a(), () => h.forEach((u) => u());\n}\nfunction xs(t = !0) {\n  const e = [\n    w(\"reload_iframe\", () => {\n      A(\"iframe_will_reload\"), window.location.reload();\n    })\n  ], s = () => e.forEach((n) => n());\n  if (t) {\n    const n = document.createElement(\"style\");\n    n.id = \"telegram-custom-styles\", document.head.appendChild(n), e.push(\n      w(\"set_custom_style\", (r) => {\n        n.innerHTML = r;\n      }),\n      () => document.head.removeChild(n)\n    );\n  }\n  return A(\"iframe_ready\", { reload_supported: !0 }), s;\n}\nfunction Ps() {\n  return typeof window > \"u\";\n}\nasync function Cs() {\n  if (de(window))\n    return !0;\n  try {\n    return await d({ method: \"web_app_request_theme\", event: \"theme_changed\", timeout: 100 }), !0;\n  } catch {\n    return !1;\n  }\n}\nfunction Ts(t) {\n  const e = typeof t == \"string\" ? X(t) : t;\n  qe(e);\n  function s(r) {\n    if (typeof r == \"string\")\n      try {\n        const { eventType: i } = ue(r);\n        i === \"web_app_request_theme\" && z(\"theme_changed\", {\n          theme_params: JSON.parse(Ie(e.themeParams))\n        }), i === \"web_app_request_viewport\" && z(\"viewport_changed\", {\n          width: window.innerWidth,\n          height: window.innerHeight,\n          is_state_stable: !0,\n          is_expanded: !0\n        });\n      } catch {\n      }\n  }\n  if (_e()) {\n    const r = window.parent.postMessage.bind(window.parent);\n    window.parent.postMessage = (i) => {\n      s(i), r(i);\n    };\n    return;\n  }\n  if (le(window)) {\n    const r = window.external.notify.bind(window.external);\n    window.external.notify = (i) => {\n      s(i), r(i);\n    };\n    return;\n  }\n  const n = window.TelegramWebviewProxy;\n  window.TelegramWebviewProxy = {\n    ...n || {},\n    postEvent(...r) {\n      s(JSON.stringify({ eventType: r[0], eventData: r[1] })), n && n.postEvent(...r);\n    }\n  };\n}\nfunction jt(t) {\n  return t instanceof V;\n}\nfunction Rs(t, e) {\n  return jt(t) && t.type === e;\n}\nfunction L(t, e) {\n  let s, n, r;\n  return typeof t == \"string\" ? s = t : (s = t.pathname === void 0 ? e : t.pathname, n = t.params, r = t.id), Object.freeze({\n    id: r || (Math.random() * 2 ** 14 | 0).toString(16),\n    pathname: s,\n    params: n\n  });\n}\nclass Ft {\n  constructor(e, s, n = A) {\n    /**\n     * Navigation history.\n     */\n    c(this, \"history\");\n    c(this, \"ee\", new R());\n    /**\n     * True, if current navigator is currently attached.\n     */\n    c(this, \"attached\", !1);\n    /**\n     * Goes to the previous history item.\n     */\n    c(this, \"back\", () => this.go(-1));\n    /**\n     * Adds new event listener.\n     */\n    c(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    c(this, \"off\", this.ee.off.bind(this.ee));\n    if (this._index = s, this.postEvent = n, e.length === 0)\n      throw f(Ze, \"History should not be empty.\");\n    if (s < 0 || s >= e.length)\n      throw f(\n        Ke,\n        \"Index should not be zero and higher or equal than history size.\"\n      );\n    this.history = e.map((r) => L(r, \"\"));\n  }\n  /**\n   * Allows this navigator to control the `BackButton` visibility state. It also tracks the\n   * `BackButton` clicks and calls the `back` method.\n   */\n  attach() {\n    this.attached || (this.attached = !0, this.sync(), w(\"back_button_pressed\", this.back));\n  }\n  /**\n   * Currently active history item.\n   */\n  get current() {\n    return this.history[this.index];\n  }\n  /**\n   * Prevents current navigator from controlling the BackButton visibility state.\n   */\n  detach() {\n    this.attached = !1, B(\"back_button_pressed\", this.back);\n  }\n  /**\n   * Goes to the next history item.\n   */\n  forward() {\n    this.go(1);\n  }\n  /**\n   * Changes currently active history item index by the specified delta. This method doesn't\n   * change index in case, the updated index points to the non-existing history item. This behavior\n   * is preserved until the `fit` argument is specified.\n   * @param delta - index delta.\n   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.\n   */\n  go(e, s) {\n    const n = this.index + e, r = Math.min(\n      Math.max(0, n),\n      this.history.length - 1\n    );\n    (n === r || s) && this.replaceAndMove(r, this.history[r]);\n  }\n  /**\n   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.\n   *\n   * If \"fit\" option was specified and index is out of bounds, it will be cut to the nearest\n   * bound.\n   * @param index - target index.\n   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.\n   */\n  goTo(e, s) {\n    this.go(e - this.index, s);\n  }\n  /**\n   * True if navigator has items before the current item.\n   */\n  get hasPrev() {\n    return this.index > 0;\n  }\n  /**\n   * True if navigator has items after the current item.\n   */\n  get hasNext() {\n    return this.index !== this.history.length - 1;\n  }\n  /**\n   * Currently active history item index.\n   */\n  get index() {\n    return this._index;\n  }\n  /**\n   * Adds a new history item removing all after the current one.\n   * @param item - item to add.\n   */\n  push(e) {\n    this.hasNext && this.history.splice(this.index + 1), this.replaceAndMove(this.index + 1, L(e, this.current.pathname));\n  }\n  /**\n   * Replaces the current history item.\n   * @param item - item to replace the current item with.\n   */\n  replace(e) {\n    this.replaceAndMove(this.index, L(e, this.current.pathname));\n  }\n  /**\n   * Sets history item by the specified index.\n   * @param index - history item index to replace.\n   * @param historyItem - history item to set.\n   */\n  replaceAndMove(e, s) {\n    const n = e - this.index;\n    if (!n && this.current === s)\n      return;\n    const r = this.current;\n    if (this.index !== e) {\n      const i = this._index;\n      this._index = e, this.attached && i > 0 != e > 0 && this.sync();\n    }\n    this.history[e] = s, this.ee.emit(\"change\", {\n      navigator: this,\n      from: r,\n      to: this.current,\n      delta: n\n    });\n  }\n  /**\n   * Actualizes the `BackButton` visibility state.\n   */\n  sync() {\n    this.postEvent(\"web_app_setup_back_button\", { is_visible: !!this.index });\n  }\n}\nfunction $({\n  params: t,\n  ...e\n}) {\n  return { ...t || { hash: \"\", search: \"\" }, ...e };\n}\nfunction N(t) {\n  const e = typeof t == \"string\" ? t.startsWith(\"/\") : !!(t.pathname && t.pathname.startsWith(\"/\")), s = q(t);\n  return `${e ? s.pathname : s.pathname.slice(1)}${s.search}${s.hash}`;\n}\nfunction W(t, e, s) {\n  let n, r;\n  typeof t == \"string\" ? n = t : (n = N(t), s = t.state, r = t.id);\n  const { pathname: i, search: o, hash: a } = new URL(n, `http://a${I(e, \"/\")}`);\n  return { id: r, pathname: i, params: { hash: a, search: o, state: s } };\n}\nasync function T(t) {\n  return t === 0 ? !0 : Promise.race([\n    new Promise((e) => {\n      const s = G(\"popstate\", () => {\n        s(), e(!0);\n      });\n      window.history.go(t);\n    }),\n    // Usually, it takes about 1ms to emit this event, but we use some buffer.\n    new Promise((e) => {\n      setTimeout(e, 50, !1);\n    })\n  ]);\n}\nasync function Jt() {\n  if (window.history.length <= 1 || (window.history.pushState(null, \"\"), await T(1 - window.history.length)))\n    return;\n  let e = await T(-1);\n  for (; e; )\n    e = await T(-1);\n}\nfunction Be(t) {\n  return q(t).pathname;\n}\nconst ie = 0, U = 1, H = 2;\nclass Le {\n  constructor(e, s, { postEvent: n, hashMode: r = \"classic\", base: i } = {}) {\n    c(this, \"navigator\");\n    c(this, \"ee\", new R());\n    c(this, \"hashMode\");\n    c(this, \"base\");\n    /**\n     * Shows whether the navigator is currently attached to the browser history.\n     */\n    c(this, \"attached\", !1);\n    /**\n     * Handles the window \"popstate\" event.\n     * @param state - event state.\n     */\n    c(this, \"onPopState\", ({ state: e }) => {\n      if (e === null)\n        return this.push(this.parsePath(window.location.href));\n      e === ie ? window.history.forward() : e === U && this.back(), e === H && this.forward();\n    });\n    /**\n     * Underlying navigator change event listener.\n     */\n    c(this, \"onNavigatorChange\", async ({\n      to: e,\n      from: s,\n      delta: n\n    }) => {\n      this.attached && await this.syncHistory(), this.ee.emit(\"change\", {\n        delta: n,\n        from: $(s),\n        to: $(e),\n        navigator: this\n      });\n    });\n    /**\n     * Adds new event listener.\n     */\n    c(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    c(this, \"off\", this.ee.off.bind(this.ee));\n    this.navigator = new Ft(\n      e.map((o) => W(o, \"/\")),\n      s,\n      n\n    ), this.navigator.on(\"change\", (o) => {\n      this.onNavigatorChange(o);\n    }), this.hashMode = r, this.base = Be(i || \"\");\n  }\n  /**\n   * Attaches current navigator to the browser history allowing navigator to manipulate it.\n   */\n  async attach() {\n    this.attached || (this.attached = !0, this.navigator.attach(), window.addEventListener(\"popstate\", this.onPopState), await this.syncHistory());\n  }\n  /**\n   * Goes back in history by 1.\n   */\n  back() {\n    this.navigator.back();\n  }\n  /**\n   * Detaches current navigator from the browser history.\n   */\n  detach() {\n    this.attached = !1, this.navigator.detach(), window.removeEventListener(\"popstate\", this.onPopState);\n  }\n  /**\n   * Goes forward in history.\n   */\n  forward() {\n    return this.navigator.forward();\n  }\n  /**\n   * Current history cursor.\n   */\n  get index() {\n    return this.navigator.index;\n  }\n  /**\n   * Current history item identifier.\n   */\n  get id() {\n    return this.navigator.current.id;\n  }\n  /**\n   * Changes currently active history item index by the specified delta. This method doesn't\n   * change index in case, the updated index points to the non-existing history item. This behavior\n   * is preserved until the `fit` argument is specified.\n   * @param delta - index delta.\n   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.\n   */\n  go(e, s) {\n    return this.navigator.go(e, s);\n  }\n  /**\n   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.\n   *\n   * If \"fit\" option was specified and index is out of bounds, it will be cut to the nearest\n   * bound.\n   * @param index - target index.\n   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.\n   */\n  goTo(e, s) {\n    this.navigator.goTo(e, s);\n  }\n  /**\n   * Current history item hash.\n   * @see URL.hash\n   * @example\n   * \"\", \"#my-hash\"\n   */\n  get hash() {\n    return (this.navigator.current.params || {}).hash || \"\";\n  }\n  /**\n   * True if navigator has items before the current item.\n   */\n  get hasPrev() {\n    return this.navigator.hasPrev;\n  }\n  /**\n   * True if navigator has items after the current item.\n   */\n  get hasNext() {\n    return this.navigator.hasNext;\n  }\n  /**\n   * Navigation history.\n   */\n  get history() {\n    return this.navigator.history.map($);\n  }\n  /**\n   * Path, including pathname, search and hash.\n   * @example Pathname only.\n   * \"/pathname\"\n   * @example Pathname + search.\n   * \"/pathname?search\"\n   * @example Pathname + hash.\n   * \"/pathname#hash\"\n   * @example Pathname + search + hash.\n   * \"/pathname?search#hash\"\n   */\n  get path() {\n    return N(this);\n  }\n  /**\n   * Current pathname. Always starts with the slash.\n   * @see URL.pathname\n   * @example\n   * \"/\", \"/abc\"\n   */\n  get pathname() {\n    return this.navigator.current.pathname;\n  }\n  /**\n   * Depending on the current navigation type, parses incoming path and returns it presented as\n   * an object. In other words, this method parses the passed path and returns object, describing\n   * how the navigator \"sees\" it.\n   *\n   * @example Hash mode is omitted.\n   * parsePath('/abc?a=1#hash');\n   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }\n   * parsePath('http://example.com/abc?a=1#hash');\n   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }\n   *\n   * @example Hash mode is enabled.\n   * parsePath('/abc?a=1#tma?is=cool#yeah');\n   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }\n   * parsePath('http://example.com/abc?a=1#tma?is=cool#yeah');\n   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }\n   */\n  parsePath(e) {\n    let s = q(e);\n    return this.hashMode && (s = q(s.hash.slice(1))), {\n      pathname: s.pathname,\n      search: s.search,\n      hash: s.hash\n    };\n  }\n  push(e, s) {\n    const n = W(e, this.path), { state: r = s } = n.params;\n    this.navigator.push({ ...n, params: { ...n.params, state: r } });\n  }\n  replace(e, s) {\n    const n = W(e, this.path), { state: r = s } = n.params;\n    this.navigator.replace({ ...n, params: { ...n.params, state: r } });\n  }\n  /**\n   * Combines the navigator `base` property with the passed path data applying the navigator\n   * navigation mode.\n   * @param value - path presented as string or URLLike.\n   */\n  renderPath(e) {\n    const s = (this.base.length === 1 ? \"\" : this.base) + I(N(e), \"/\");\n    return this.hashMode ? I(s.slice(1), this.hashMode === \"classic\" ? \"#\" : \"#/\") : s;\n  }\n  /**\n   * Synchronizes current navigator state with browser history.\n   */\n  async syncHistory() {\n    window.removeEventListener(\"popstate\", this.onPopState);\n    const { state: e } = this, s = this.renderPath(this);\n    await Jt(), this.hasPrev && this.hasNext ? (window.history.replaceState(U, \"\"), window.history.pushState(e, \"\", s), window.history.pushState(H, \"\"), await T(-1)) : this.hasPrev ? (window.history.replaceState(U, \"\"), window.history.pushState(e, \"\", s)) : this.hasNext ? (window.history.replaceState(e, s), window.history.pushState(H, \"\"), await T(-1)) : (window.history.replaceState(ie, \"\"), window.history.pushState(e, \"\", s)), window.addEventListener(\"popstate\", this.onPopState);\n  }\n  /**\n   * Current query parameters.\n   * @see URL.search\n   * @example\n   * \"\", \"?\", \"?a=1\"\n   */\n  get search() {\n    return (this.navigator.current.params || {}).search || \"\";\n  }\n  /**\n   * Current history item state.\n   */\n  get state() {\n    return (this.navigator.current.params || {}).state;\n  }\n}\nfunction Qt(t) {\n  t || (t = {});\n  const { href: e, hash: s } = window.location;\n  let n = N(\n    t.hashMode === null ? e : s.includes(\"?\") ? s.slice(1) : `?${s.slice(1)}`\n  );\n  const r = t.base ? Be(t.base) : void 0;\n  if (r) {\n    if (!n.startsWith(r))\n      throw f(\n        Xe,\n        `Path \"${n}\" expected to be starting with \"${r}\"`\n      );\n    n = n.slice(r.length);\n  }\n  return new Le([n], 0, t);\n}\nfunction As(t) {\n  const e = t.match(/#(.+)/);\n  return e ? e[1] : null;\n}\nfunction Yt(t, e) {\n  if (ke()) {\n    const s = sessionStorage.getItem(t);\n    if (s)\n      try {\n        const { index: n, history: r } = JSON.parse(s);\n        return new Le(\n          r,\n          n,\n          e\n        );\n      } catch (n) {\n        console.error(\"Unable to restore hash navigator state.\", n);\n      }\n  }\n  return Qt(e);\n}\nfunction Is(t, e) {\n  const s = Yt(t, e), n = () => sessionStorage.setItem(t, JSON.stringify({\n    index: s.index,\n    history: s.history\n  }));\n  return s.on(\"change\", n), n(), s;\n}\nexport {\n  lt as BackButton,\n  Ft as BasicNavigator,\n  xt as BiometryManager,\n  Le as BrowserNavigator,\n  Ct as ClosingBehavior,\n  It as CloudStorage,\n  Xe as ERR_INVALID_PATH_BASE,\n  Je as ERR_INVOKE_CUSTOM_METHOD_RESPONSE,\n  je as ERR_METHOD_PARAMETER_UNSUPPORTED,\n  ze as ERR_METHOD_UNSUPPORTED,\n  Ze as ERR_NAVIGATION_HISTORY_EMPTY,\n  Ke as ERR_NAVIGATION_INDEX_INVALID,\n  Xt as ERR_NAVIGATION_ITEM_INVALID,\n  ce as ERR_PARSE,\n  es as ERR_SSR_INIT,\n  Qe as ERR_TIMED_OUT,\n  Ye as ERR_UNEXPECTED_TYPE,\n  Fe as ERR_UNKNOWN_ENV,\n  R as EventEmitter,\n  qt as HapticFeedback,\n  kt as InitData,\n  Nt as Invoice,\n  Vt as MainButton,\n  Bt as MiniApp,\n  $t as Popup,\n  Wt as QRScanner,\n  V as SDKError,\n  Ut as SettingsButton,\n  Ht as SwipeBehavior,\n  Ot as ThemeParams,\n  Gt as Utils,\n  zt as Viewport,\n  At as array,\n  vs as bindMiniAppCSSVars,\n  Es as bindThemeParamsCSSVars,\n  Ss as bindViewportCSSVars,\n  b as boolean,\n  ge as captureSameReq,\n  j as classNames,\n  ot as compareVersions,\n  Qt as createBrowserNavigatorFromLocation,\n  ht as createPostEvent,\n  q as createSafeURL,\n  Ee as date,\n  As as getHash,\n  Be as getPathname,\n  ns as initBackButton,\n  rs as initBiometryManager,\n  is as initClosingBehavior,\n  os as initCloudStorage,\n  as as initHapticFeedback,\n  cs as initInitData,\n  ps as initInvoice,\n  us as initMainButton,\n  ls as initMiniApp,\n  Is as initNavigator,\n  ds as initPopup,\n  _s as initQRScanner,\n  fs as initSettingsButton,\n  gs as initSwipeBehavior,\n  ws as initThemeParams,\n  ms as initUtils,\n  ys as initViewport,\n  xs as initWeb,\n  C as invokeCustomMethod,\n  ye as isColorDark,\n  _e as isIframe,\n  ke as isPageReload,\n  Q as isRGB,\n  pt as isRGBShort,\n  jt as isSDKError,\n  Rs as isSDKErrorOfType,\n  Ps as isSSR,\n  Cs as isTMA,\n  g as json,\n  ss as mergeClassNames,\n  Ts as mockTelegramEnv,\n  y as number,\n  B as off,\n  w as on,\n  hs as parseInitData,\n  X as parseLaunchParams,\n  De as parseThemeParams,\n  A as postEvent,\n  d as request,\n  Pt as requestBiometryInfo,\n  bs as requestThemeParams,\n  Me as requestViewport,\n  vt as retrieveLaunchParams,\n  _t as rgb,\n  K as searchParams,\n  yt as serializeLaunchParams,\n  Ie as serializeThemeParams,\n  m as setCSSVar,\n  Kt as setDebug,\n  ts as setTargetOrigin,\n  p as string,\n  He as subscribe,\n  v as supports,\n  ct as targetOrigin,\n  me as toRGB,\n  ae as unsubscribe,\n  N as urlToPath,\n  be as withTimeout\n};\n//# sourceMappingURL=index.js.map\n","import { useCallback, useEffect, useMemo, useState } from 'react';\nimport type { Location, Navigator, To, NavigateOptions } from 'react-router-dom';\nimport { BrowserNavigator, createSafeURL, urlToPath } from '@telegram-apps/sdk';\n\n/**\n * Uses the passed Mini Apps navigator and returns a tuple containing reactive values\n * representing current location and react-router-dom navigator.\n * @param nav - Mini Apps navigator.\n */\nexport function useIntegration<State>(nav: BrowserNavigator<State>): [Location, Navigator] {\n  // Creates location based on the Mini Apps navigator.\n  const createLocation = useCallback((): Location => ({\n    state: nav.state,\n    key: nav.id,\n    pathname: nav.pathname,\n    hash: nav.hash,\n    search: nav.search,\n  }), [nav]);\n\n  const [location, setLocation] = useState(createLocation);\n\n  // todo: We should check if state is always State.\n  const navigate = useCallback((to: To, state?: State, options?: NavigateOptions) => {\n    options ||= {};\n    if (state === undefined) {\n      state = options.state;\n    }\n    const path = urlToPath(to);\n    if (options.replace) {\n      nav.replace(path, state);\n    } else {\n      nav.push(path, state);\n    }\n  }, [nav]);\n\n  // Create Navigator appropriate to the react-router-dom package.\n  const navigator = useMemo<Navigator>(() => ({\n    go(delta) {\n      nav.go(delta);\n    },\n    push: navigate,\n    replace: navigate,\n    createHref: (to) => nav.renderPath(urlToPath(to)),\n    encodeLocation: (to) => createSafeURL(nav.renderPath(urlToPath(to))),\n  }), [nav]);\n\n  // When Mini Apps navigator changes its location, we should actualize the reactive values.\n  useEffect(() => {\n    return nav.on('change', () => setLocation(createLocation()));\n  }, [nav, createLocation]);\n\n  return [location, navigator];\n}\n"],"names":["V","s","n","f","Ye","ce","E","D","S","b","he","i","o","a","pe","g","y","p","I","q","N","useIntegration","nav","createLocation","useCallback","location","setLocation","useState","navigate","to","state","options","path","urlToPath","navigator","useMemo","delta","createSafeURL","useEffect"],"mappings":"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"}