import { useCallback as b, useState as P, useMemo as U, useEffect as O } from "react";
class d extends Error {
  constructor(e, o, a) {
    super(o, { cause: a }), this.type = e, Object.setPrototypeOf(this, d.prototype);
  }
}
function y(t, e, o) {
  return new d(t, e, o);
}
const R = "ERR_UNEXPECTED_TYPE", $ = "ERR_PARSE";
function h() {
  return y(R, "Value has unexpected type");
}
class E {
  constructor(e, o, a) {
    this.parser = e, this.isOptional = o, this.type = a;
  }
  /**
   * Attempts to parse passed value
   * @param value - value to parse.
   * @throws {SDKError} ERR_PARSE
   * @see ERR_PARSE
   */
  parse(e) {
    if (!(this.isOptional && e === void 0))
      try {
        return this.parser(e);
      } catch (o) {
        throw y(
          $,
          `Unable to parse value${this.type ? ` as ${this.type}` : ""}`,
          o
        );
      }
  }
  optional() {
    return this.isOptional = !0, this;
  }
}
function _(t, e) {
  return () => new E(t, !1, e);
}
const p = _((t) => {
  if (typeof t == "boolean")
    return t;
  const e = String(t);
  if (e === "1" || e === "true")
    return !0;
  if (e === "0" || e === "false")
    return !1;
  throw h();
}, "boolean");
function S(t, e) {
  const o = {};
  for (const a in t) {
    const r = t[a];
    if (!r)
      continue;
    let c, s;
    if (typeof r == "function" || "parse" in r)
      c = a, s = typeof r == "function" ? r : r.parse.bind(r);
    else {
      const { type: n } = r;
      c = r.from || a, s = typeof n == "function" ? n : n.parse.bind(n);
    }
    try {
      const n = s(e(c));
      n !== void 0 && (o[a] = n);
    } catch (n) {
      throw y($, `Unable to parse field "${a}"`, n);
    }
  }
  return o;
}
function x(t) {
  let e = t;
  if (typeof e == "string" && (e = JSON.parse(e)), typeof e != "object" || e === null || Array.isArray(e))
    throw h();
  return e;
}
function u(t, e) {
  return new E((o) => {
    const a = x(o);
    return S(t, (r) => a[r]);
  }, !1, e);
}
const l = _((t) => {
  if (typeof t == "number")
    return t;
  if (typeof t == "string") {
    const e = Number(t);
    if (!Number.isNaN(e))
      return e;
  }
  throw h();
}, "number"), i = _((t) => {
  if (typeof t == "string" || typeof t == "number")
    return t.toString();
  throw h();
}, "string");
u({
  req_id: i(),
  data: (t) => t === null ? t : i().optional().parse(t)
}), u({
  req_id: i(),
  result: (t) => t,
  error: i().optional()
}), u({
  height: l(),
  width: (t) => t == null ? window.innerWidth : l().parse(t),
  is_state_stable: p(),
  is_expanded: p()
});
u({
  id: l(),
  type: i(),
  title: i(),
  photoUrl: {
    type: i().optional(),
    from: "photo_url"
  },
  username: i().optional()
}, "Chat").optional();
u({
  addedToAttachmentMenu: {
    type: p().optional(),
    from: "added_to_attachment_menu"
  },
  allowsWriteToPm: {
    type: p().optional(),
    from: "allows_write_to_pm"
  },
  firstName: {
    type: i(),
    from: "first_name"
  },
  id: l(),
  isBot: {
    type: p().optional(),
    from: "is_bot"
  },
  isPremium: {
    type: p().optional(),
    from: "is_premium"
  },
  languageCode: {
    type: i().optional(),
    from: "language_code"
  },
  lastName: {
    type: i().optional(),
    from: "last_name"
  },
  photoUrl: {
    type: i().optional(),
    from: "photo_url"
  },
  username: i().optional()
}, "User").optional();
function w(t, e) {
  return t.startsWith(e) ? t : `${e}${t}`;
}
function N(t) {
  return new URL(
    typeof t == "string" ? t : `${t.pathname || ""}${w(t.search || "", "?")}${w(t.hash || "", "#")}`,
    "http://a"
  );
}
function m(t) {
  const e = typeof t == "string" ? t.startsWith("/") : !!(t.pathname && t.pathname.startsWith("/")), o = N(t);
  return `${e ? o.pathname : o.pathname.slice(1)}${o.search}${o.hash}`;
}
function A(t) {
  const e = b(() => ({
    state: t.state,
    key: t.id,
    pathname: t.pathname,
    hash: t.hash,
    search: t.search
  }), [t]), [o, a] = P(e), r = b((s, n, f) => {
    f || (f = {}), n === void 0 && (n = f.state);
    const g = m(s);
    f.replace ? t.replace(g, n) : t.push(g, n);
  }, [t]), c = U(() => ({
    go(s) {
      t.go(s);
    },
    push: r,
    replace: r,
    createHref: (s) => t.renderPath(m(s)),
    encodeLocation: (s) => N(t.renderPath(m(s)))
  }), [t]);
  return O(() => t.on("change", () => a(e())), [t, e]), [o, c];
}
export {
  A as useIntegration
};
//# sourceMappingURL=index.js.map
